#!/usr/bin/perl
#!/usr/bin/perl -T

#- Copyright (C) 1999 MandrakeSoft (pixel@linux-mandrake.com)
#-
#- This program is free software; you can redistribute it and/or modify
#- it under the terms of the GNU General Public License as published by
#- the Free Software Foundation; either version 2, or (at your option)
#- any later version.
#-
#- This program is distributed in the hope that it will be useful,
#- but WITHOUT ANY WARRANTY; without even the implied warranty of
#- MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
#- GNU General Public License for more details.
#-
#- You should have received a copy of the GNU General Public License
#- along with this program; if not, write to the Free Software
#- Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA.

#use strict qw(subs vars refs);
use urpm;

#- default options.
my $auto = 0;
my $force = 0;
my $X = 0;
my $all = 0;
my $rpm_opt = "-U";
my $datadir = "/var/lib/urpmi";

my $uid;
my @files;
my @names;

my %I18N;
load_po();

$ENV{PATH} = "/sbin:/usr/sbin:/bin:/usr/bin:/usr/X11R6/bin";
delete @ENV{qw(ENV BASH_ENV IFS CDPATH)};
($<, $uid) = ($>, $<);
    
sub usage {
    die(_("usage: urpmi [-h] [--auto] [--force] [-a] [-v] package_name|rpm_file [package_names|rpm_files...]\n"));
}

#- parse arguments list.
my @nextargv;
for (@ARGV) {
    /^--help$/ and do { usage; next };
    /^--auto$/ and do { $auto = 1; next };
    /^--force$/ and do { $force = 1; next };
    /^--X$/ and do { $X = 1; next };
    /^--best-output$/ and do { $X ||= $ENV{DISPLAY} && system('/usr/X11R6/bin/xtest', '') == 0; next };
    /^--comment$/ and do { push @nextargv, undef; next };
    /^-(.*)$/ and do { foreach (split //, $1) {
	/[\?h]/ and do { usage; next };
	/a/ and do { $all = 1; next };
	/v/ and do { $rpm_opt = "-Uvh"; next };
	die "urpmi: unknown option \"-$1\", check usage with --help\n"; } next };
    @nextargv and do { my $r = shift @nextargv; $r and $$r = $_; next };
    /\.rpm$/ and do { -r $_ or print STDERR "urpmi: cannot read rpm file \"$_\"\n", next;
		      push @files, untaint($_); next };
    push @names, $_;
}

#- log only at this point in case of query usage.
log_it(scalar localtime, " urpmi called with @ARGV\n");

open SAVEOUT, ">&STDOUT";
open SAVEERR, ">&STDERR";
open STDOUT, "|tee -a /var/log/urpmi.log" or die;
open STDERR, "|tee >&2 -a /var/log/urpmi.log" or die;
select STDERR; $| = 1;     # make unbuffered
select STDOUT; $| = 1;     # make unbuffered

#- params contains informations to parse installed system.
my $urpm = new urpm;

$urpm->read_depslist;

if (@files) {
    $uid == 0 or die _("Only superuser is allowed to install local packages");

    #- read provides file which is needed only to compute incremental
    #- dependancies, of files provided.
    $urpm->read_provides;

    #- compute depslist of files provided on command line.
    $urpm->{params}->read_rpms($_) foreach @files;
    $urpm->{params}->compute_depslist;

    #- gets full names of packages, sanity check of pathname.
    m|(.*/)?(.*)\.[^.]+\.rpm$| and push @names, $2 foreach @files;
    m|^/| or $_ = "./$_" foreach @files;
}

#- reparse whole internal depslist to match against newer packages only.
# TO MOVE TO urpm management of ignored medium
$urpm->{params}->relocate_depslist();


#- search the packages according the selection given by the user,
#- basesystem is added to the list so if it need to be upgraded, all its dependancy
#- will be updated too.
my %packages;
$urpm->search_packages(\%packages, [ 'basesystem', @names], all => $all) or $force or exit 1;

#- filter to add in packages selected required packages.
$urpm->filter_packages_to_upgrade(\%packages, sub {
    my ($urpm, @choices_id) = @_;
    my $n = 1; #- default value.
    my @l = map { my $info = $urpm->{params}{depslist}[$_]; "$info->{name}-$info->{version}-$info->{release}" } @choices_id;

    if (@l > 1 && !$auto) {
	my $msg = _("One of the following packages is needed:");
	if ($X) {
	    `gchooser "$msg" @l`;
	    $n = $? >> 8 || die;
	} else {
	    print SAVEOUT "$msg\n";
	    my $i = 0; foreach (@l) { print SAVEOUT " ", ++$i, "- $_\n"; }
	    while (1) {
		print SAVEOUT _("What is your choice? (1-%d) ", $i);
		$n = <STDIN>;
		1 <= $n && $n <= $i and last;
		print SAVEOUT _("Sorry, bad choice, try again\n");
	    }
	}
    }

    $choices_id[$n - 1];
});

#- package to install as a array of strings.
my @to_install;

#- check if there is at least one package to install that
#- has not been given by the user.
my $ask_user;
my $sum = 0;
foreach (keys %packages) {
    defined $packages{$_} and $ask_user = 1;
    my $info  = $urpm->{params}{depslist}[$_];
    $sum += $info->{size};
    push @to_install, "$info->{name}-$info->{version}-$info->{release}";
}
if (!$auto) {
    if ($ask_user) {
	my $msg = _("To satisfy dependencies, the following packages are going to be installed (%d MB)", toMb($sum));
	my $msg2 = _("Is it ok?");
	if ($X) {
	    my $p = join "\n", @to_install;
	    my $ok = _("Ok");
	    my $cancel = _("Cancel");
	    `gmessage -default $ok -buttons "$ok:0,$cancel:2" "$msg:\n$p\n\n$msg2"`;
	    $? and exit 0;
	} else {
	    print SAVEOUT "$msg:\n@to_install\n$msg2 (Y/n) ";
	    <STDIN> =~ /n/i and exit 0;
	}
    }
}

my $to_install = join '|', map { quotemeta($_) } @to_install;
my %long;
my %name;
my %removables;

foreach my $list (rpmlistfiles($datadir)) {
    open F, "$datadir/$list" or die("urpmi: error opening $list\n");
    $list =~ s/list\.//;
    foreach (<F>) { chop; m|/($to_install)| and $long{$1} = untaint($_), $name{$1} = untaint($list) }
    close F;
}

foreach (@files) { 
    m|/($to_install)| and $long{$1} = $_
}

my %try2mount;
my @to_install_long;

foreach my $l (@to_install) {
    local $_ = $long{$l} or die("urpmi: package $l is not available\n");
    if (s|removable_(\w+)_(\d*):/||) {
	my $n = "$2-$name{$l}";
	$removables{$n}->{name} = $name{$l};
	$removables{$n}->{device} = $1;
	push @{$removables{$n}->{list}}, $_;
    } else {
	if (s|^file:/||) {
	    if (m|^(/mnt/.*?)/|) {
		-e $_ || $try2mount{$1} or $try2mount{$1} = 1, `mount $1 2>/dev/null`;
	    }
	}
	push @to_install_long, $_;
    }
}

my $something_was_installed;

install(@to_install_long) unless $removables{0} || $removables{1};

foreach (sort keys %removables) {
    my $f = @{$removables{$_}->{list}}[0];
    my $dev = $removables{$_}->{device};
    `mount /dev/$dev 2>/dev/null`;
    unless (-e $f) {
	`umount /dev/$dev  2>/dev/null ; eject $dev  2>/dev/null`;
	message(_("Please insert the %s named %s", $removables{$_}->{device}, $removables{$_}->{name}));
	unless ($X) {
	    print SAVEOUT _("Press enter when it's done...");
	    <STDIN>;
	}
	`mount /dev/$dev  2>/dev/null`;
	unless (-e $f) {
	    message(_("Sorry can't find file %s, exiting", $f));
	    exit 1;
	}
    }
    install(@{$removables{$_}->{list}});
}

install(@to_install_long) if $removables{0} || $removables{1};

$something_was_installed or message_auto(_("everything already installed"));


sub install {
    @_ or return;
	
    $something_was_installed = 1;
    print SAVEOUT _("installing %s\n", join(' ', @_));
    log_it(scalar localtime, " @_\n");
    system($X ? "grpmi" : ("rpm", $rpm_opt), @_);
    if ($?) {
	message(_("Installation failed"));
	$X and exit 1; #- grpmi handles --nodeps and --force by itself

	m|^/| && !-e $_ and exit 1 foreach @_; #- missing local file

	print SAVEOUT _("Try installation without checking dependencies?"), " (Y/n) ";
	$force or <STDIN> =~ /n/i and exit 1;
	system("rpm", $rpm_opt, "--nodeps", @_);	

	if ($?) {
	    message(_("Installation failed"));
	    print SAVEOUT _("Try installation even more strongly (--force)?"), " (Y/n) ";
	    $force or <STDIN> =~ /n/i and exit 0;
	    system("rpm", $rpm_opt, "--nodeps", "--force", @_);	
	}
    }
}

sub toMb {
    my $nb = $_[0] / 1024 / 1024;
    int $nb + 0.5;
}

sub message { $X ? `gmessage -default Ok -buttons Ok "$_[0]"` : print SAVEOUT "$_[0]\n"; }

sub message_auto { $auto ? print SAVEOUT "$_[0]\n" : message($_[0]); }

sub _ {
    my $s = shift @_; my $t = translate($s);
    $t && ref $t or return sprintf $t, @_;
    my ($T, @p) = @$t;
    sprintf $T, @_[@p];
}
sub translate { $I18N{$_[0]} || $_[0]; }

sub log_it {
    local *LOG;
    open LOG, ">>/var/log/urpmi.log" or die "can't ouptput to log file\n";
    print LOG @_;
}

sub untaint {
    my @r = ();
    foreach (@_) {
        /(.*)/;
	push @r, $1;
    }
    @r == 1 ? $r[0] : @r
}

sub load_po {
    my ($from, $to, $state, $fuzzy);

    my $lang = $ENV{LANGUAGE} || $ENV{LC_ALL} || $ENV{LC_MESSAGES} || $ENV{LANG};
    my $f; -e ($f = "/usr/share/locale/$_/LC_MESSAGES/urpmi.po") and last foreach split ':', $lang;

    local *F; open F, $f or return;
    foreach (<F>) {
	/^msgstr/ and $state = 1;
	/^msgid/  && !$fuzzy and $state = 2;

	if (/^(#|$)/ && $state != 3) {
	    $state = 3;
            s/\\n/\n/g foreach $from, $to;

	    if (my @l = $to =~ /%(\d+)\$/g) {
		$to =~ s/%(\d+)\$/%/g;
		$to = [ $to, map { $_ - 1 } @l ];
	    }
	    $I18N{$from} = $to if $from;
	    $from = $to = '';
	}
	$to .= (/"(.*)"/)[0] if $state == 1;
	$from .= (/"(.*)"/)[0] if $state == 2;

	$fuzzy = /^#, fuzzy/;
    }
}

sub rpmlistfiles {
    my ($d) = @_;
    local *F;
    opendir F, $d or die "all: can't open dir $d: $!\n";
    my @l = grep { /^list\.*/ } readdir F;
    closedir F;

    @l;
}
