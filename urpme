#!/usr/bin/perl

# Copyright (C) 1999,2002 MandrakeSoft <pixel@linux-mandrake.com>
#                                      <fpons@mandrakesoft.com>
#
# This program is free software; you can redistribute it and/or modify
# it under the terms of the GNU General Public License as published by
# the Free Software Foundation; either version 2, or (at your option)
# any later version.
#
# This program is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
# GNU General Public License for more details.
#
# You should have received a copy of the GNU General Public License
# along with this program; if not, write to the Free Software
# Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA.

#We only make good software ;-)
#use strict;

#use strict qw(subs vars refs);
use URPM;
use URPM::Resolve;
use urpm;

#- get I18N translation method.
import urpm _;

my (@nextargv, $root, $test, $parallel, $auto, $matches, $maymatch, @l);
my $askok = _("Is this OK?");
# Translator: Add here the keys which might be pressed in the "No"-case.
my $noexpr = _("Nn");
# Translator: Add here the keys which might be pressed in the "Yes"-case.
my $yesexpr = _("Yy");

sub usage {
    print STDERR _("urpme version %s
Copyright (C) 1999, 2000, 2001, 2002 MandrakeSoft.
This is free software and may be redistributed under the terms of the GNU GPL.

usage:
", $urpm::VERSION) . _("  --help         - print this help message.
") . _("  --auto         - automatically select a package in choices.
") . _("  --test         - verify if the installation can be achieved correctly.
") . _("  --parallel     - distributed urpmi accross machines of alias.
") . _("  -a             - select all packages matching expression.
");
    exit(0);
}

@ARGV or usage;
while (defined($_ = shift @ARGV)) {
    /^--help$/ and do { usage; next };
    /^--no-locales$/ and do { undef *_; undef *urpm::_; *_ = *urpm::_ = sub { sprintf(shift @_, @_) }; next };
    /^--?auto$/ and do { $auto = 1; next };
    /^--(no-)?test$/ and do { $test = !$1; next };
    /^--root$/ and do { push @nextargv, \$root; next };
    /^--parallel$/ and do { push @nextargv, \$parallel; next };
    /^-(.*)$/ and do { foreach (split //, $1) {
	/[\?h]/ and do { usage; next };
	/a/ and do { $matches = 1; next };
	die _("urpme: unknown option \"-%s\", check usage with --help\n", $1); } next };
    @nextargv and do { my $r = shift @nextargv; $r and $$r = $_; next };
    push @l, $_;
}

my $urpm = new urpm;
my $state = {};

#- just configure parallel mode if available.
$parallel and $urpm->configure(synthesis => 'none',
			       root => $root,
			       parallel => $parallel,
			      );

#- examine packages...
my @toremove = $urpm->find_packages_to_remove($state, \@l,
					      test => $test, matches => $matches, auto => $auto,
					      callback_notfound => sub {
						  my $urpm = shift @_;
						  $urpm->{fatal}(1, (@_ > 1 ? _("unknown packages") : _("unknown package")) .
								 ': ' . join(', ', @_)); 0 },
					      callback_fuzzy => sub {
						  my $urpm = shift @_;
						  my $match = shift @_;
						  $urpm->{fatal}(1, _("The following packages contain %s: %s",
								      $match, join(' ', @_))); 0 },
					      callback_base => sub {
						  my $urpm = shift @_;
						  foreach (@_) {
						      $urpm->{error}(_("removing package %s will break your system", $_));
						  } 0 },
					     ) or $urpm->{fatal}(0, _("Nothing to remove"));

if ($test && $auto) {
    my $msg = _("Checking to remove the following packages");
    print STDOUT "$msg:\n" . join("\n", sort { $a cmp $b } @toremove) . "\n";
} elsif (@toremove > @l && !$auto) {
    my $sum = 0;
    foreach (@toremove) {
	$sum += $state->{ask_remove}{$_}{size};
    }
    my $msg = _("To satisfy dependencies, the following packages are going to be removed (%d MB)", toMb($sum));
    print STDOUT "$msg:\n" . join("\n", sort { $a cmp $b } @toremove) . "\n$askok" . _(" (Y/n) ");
    <STDIN> =~ /[$noexpr]/ and exit 0;
}

@l = $parallel ?
  $urpm->parallel_remove(\@toremove, test => $test, translate_message => 1) :
  $urpm->remove(\@toremove, test => $test, translate_message => 1);
@l and $urpm->{fatal}(1, _("Removing failed") . ":\n" . join("\n",  map { "\t$_" } @l));

sub toMb {
    my $nb = $_[0] / 1024 / 1024;
    int $nb + 0.5;
}
